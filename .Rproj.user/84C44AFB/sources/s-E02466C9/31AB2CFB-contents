setwd("Z:/Projects/DESTATIS/PredErrorComplex/HierClassImpl/Package")

library("mlr3")
library("mlr3learners")
library("mlr3extralearners")

create_learner(
  path = "./RFiles",
  classname = "topdown",
  type = "classif",
  key = "topdown",
  algorithm = "Hierarchical top-down classification",
  package = "hierclass",
  caller = "topdown",
  feature_types = c("logical", "integer", "numeric", "factor", "ordered"),
  predict_types = c("response"),
  properties = c("multiclass"),
  gh_name = "RomanHornung",
  data_formats = "data.table"
)


# package = "rpart",
# caller = "rpart",

library("R6")
library("paradox")

library("mlr3")
library("mlr3learners")
library("mlr3extralearners")
library("mlr3misc")

source("./RFiles/learner_hierclass_classif_topdown.R")
# source("./RFiles/test_paramtest_TestPack_classif_testcl.R")
# source("./RFiles/test_TestPack_classif_testcl.R")

ordered_features = function(task, learner) {
  task$data(cols = intersect(names(learner$state$task_prototype), task$feature_names))
}




load("datasim.Rda")


task = as_task_classif(ydepvar ~ ., data = datasim)



learner = lrn("classif.topdown")


dim(datasim)

# train a model of this learner for a subset of the task
learner$train(task, row_ids = 1:400)
# this is what the decision tree looks like
learner$model



predictions = learner$predict(task, row_ids = 401:560)
predictions
class(predictions)

predictions$score(msr("classif.acc"))

predictions$response
predictions$truth


mean(predictions$response==predictions$truth)


learner$model$allclasses




names(predictions)







source("Z:/Projects/DESTATIS/PredErrorComplex/HierClassImpl/utility.R")

# https://github.com/jona2510/ADforHC
datahier <- processdata("Z:/Projects/DESTATIS/PredErrorComplex/Code/Data/HA_10_FD_b_train.arff")
# datahier <- processdata("Z:/Projects/DESTATIS/PredErrorComplex/Code/Data/HA_01_FD_b_train.arff")



yun <- as.character(unique(datahier$ydepvar))
yun <- yun[order(sapply(yun, function(x) length(strsplit(x, split="\\.")[[1]])))]
ylist <- sapply(yun, function(x) strsplit(x, split="\\.")[[1]])
allclasses <- unique(unlist(sapply(ylist, function(x) sapply(1:length(x), function(y) paste(x[1:y], collapse=".")))))

datahier$ydepvar <- factor(datahier$ydepvar, levels=allclasses)




set.seed(1234)


task = as_task_classif(ydepvar ~ ., data = datahier)



learner = lrn("classif.topdown", confid=0.1)


# train a model of this learner for a subset of the task
learner$train(task, row_ids = 1:3000)
# this is what the decision tree looks like
learner$model



predictions = learner$predict(task, row_ids = 3001:3280)
predictions
class(predictions)


predictions$score(msr("classif.acc"))



ui1 <- predictions$response
predictions$truth

ui <- data.frame(pred=predictions$response, truth=predictions$truth)

fix(ui)
learner$param_set$get_values(tags="predict")




set.seed(1234)

library("hierclass")

trmod <- topdown(ydepvar ~ . , data=datahier[1:3000,])

?predict.topdown

ui2 <- predict(trmod, data=datahier[3001:3280,])
ui3 <- predict(trmod, data=datahier[3001:3280,], confid=0.01)





aha <- data.frame(truth=datahier[3001:3280,]$ydepvar, preds=ui3)

fix(aha)

any(is.na(aha$ui1))
any(is.na(aha$ui2))


ui1
ui2


remclasses <- setdiff(learner$model$allclasses, unique(as.character(ui1)))
remclasses

all(as.character(ui2[is.na(ui1)]) %in% remclasses)
any(as.character(ui2[is.na(ui1)]) %in% aha[!is.na(aha)])




aha <- unique(as.character(ui1))


mean(aha$ui1==aha$ui2)



fix(aha)

# fix(ui)

# predictions$response
# predictions$truth


mean(predictions$response==predictions$truth)


# learner$model$allclasses





